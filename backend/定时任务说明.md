# 预约定时任务说明 

## 功能概述

系统实现了两个定时任务来自动处理预约状态：

### 1. 即将过期预约处理任务
- **执行频率**: 每30分钟执行一次
- **功能**: 查询当前时间已超过"预约结束时间前20分钟"的记录，将这些预约的状态设置为"爽约"
- **业务逻辑**: 例如预约结束时间是15:00，那么在14:40之后就会被标记为爽约
- **SQL查询逻辑**: 
  ```sql
  SELECT * FROM reservation 
  WHERE status = '已预约' 
  AND DATE_SUB(end_time, INTERVAL 20 MINUTE) <= NOW()
  AND end_time > NOW()
  ```

### 2. 已过期预约处理任务（兜底机制）
- **执行频率**: 每60分钟执行一次
- **功能**: 处理已经超过结束时间的预约，作为兜底机制
- **SQL查询逻辑**:
  ```sql
  SELECT * FROM reservation 
  WHERE status = '已预约' 
  AND end_time < NOW()
  ```

## 技术实现

### 核心文件
1. **ReservationTask.java** - 定时任务类
2. **ReservationMapper.xml** - 新增查询方法
3. **ReservationServiceImpl.java** - 业务逻辑实现
4. **ScheduleConfig.java** - 定时任务配置
5. **TaskController.java** - 手动触发接口（测试用）

### 配置说明
- 主应用类添加了 `@EnableScheduling` 注解启用定时任务
- 配置了独立的线程池避免任务阻塞
- 添加了完整的日志记录

## 测试接口

为了方便测试，提供了手动触发接口：

### 手动触发即将过期预约处理
```
POST /api/task/handleSoonExpired
```

### 手动触发已过期预约处理
```
POST /api/task/handleExpired
```

## 日志监控

定时任务执行时会输出详细日志：
- 任务开始执行日志
- 处理的记录数量
- 任务完成或失败日志

## 注意事项

1. 定时任务使用 `@Transactional` 注解确保数据一致性
2. 异常处理完善，任务失败不会影响系统运行
3. 使用独立线程池，避免阻塞其他业务
4. 20分钟的时间阈值可以根据业务需求调整